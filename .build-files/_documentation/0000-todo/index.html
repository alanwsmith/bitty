<details class="docs-section">
  <summary>TODO</summary>

  <pre>

- Strong recommendation to just use one
    bitty-v1-rc4 element on a page. Less
    mental overhead and less chance for
    potentially confusing warning messages
    about things like missing attrs. 
    It's possible to update the warnings
    to look across the entire DOM, but
    that's optimizing for a non-standard
    use case and not something I want
    to add the overhead for in terms
    of the code base, but mainly in
    terms of long-term maintenance.


- document window.bittyConfig 

- standardize error message objects: 

    { 
        level: "WARN",
        bittyUUID: this.dataset.uuid, 
        targetEl: el,
        type: "the-error-type",
        payload: {
            key1: "value1",
            key2: "value2",
            keyEtc: "valueEtc",
        }
    }

- .config = {} options. Starting with missingAttributeWarnings

- Show how to update the config through `this.api.config.whatever`

- You can forward to a function with 
`this.api.forward(null, "nameOfFunction");`. A temporary
        event is stubbed with `{ target: { dataset: { forward: "nameOfFunction" }}`
        inside the component to make the transition, but the
        `forward` value is removed prior to the 
        actual function call. This is designed to allow
        things like using a forward in side `bittyInit()`
        without having to explicitly mock an event. 

- bittyInit() can be async. When it is, it's called with
        `await`. If it's not, it's called normally.

- TODO: modules local async. If they are nested, doing
    something like `bittyInit` presents a race condition. 

- TODO: Add documentation note about `event` being pulled from `window.event`
if nothing overrides it in scope. (e.g. if you bury an incoming
event with `_event` the `event` variable will still be populated
but might now have what you expect in it. 


- TODO: Document the `this.api` for calling back into the `bitty-v1-rc4`
element and functionality from the module.

- Document `bittyInit()`

- Document that a uuid is added to each event

- Document: this.api.send(event, "SIGNAL_NAME"); 
    which replaces the original events dataset.send
    value with the SIGNAL_NAME then processes
    it from there. 

    TODO: Make sure watchers pick up
    forwarded signals

- 
    // TODO: Document that newly added elements
    // have an init/setup process that take
    // some amount of time. It happens
    // very quick but it's not instant.
    // So, be aware of race conditions.



- Show how to mimic an event with 
        {target: { dataset: { somekey: "value" }}}

  </pre>

<!--


### For Documentation Section

These more technical notes will be moved into
the Documentation section. 

__bitty-v1-rc4__ components can be powered by either
JavaScript modules or `<script>` tags embedded
directly on the page. The __data-connect__
attribute is used in both cases. 

The order of operations is:

1. Verify there's a __data-connect__
attribute on the component. Stop
processing and throw an error if there
isn't.

2. Use the value from the __data-conneciton__
attribute to see if there's a JavaScript
Map on the window named __BittyClasses__
with a key that mathces the value and contains
a class. For example, 

    __data-connect="InlineExample"__

    would look for:

    __bittyClasses.InlineExample__

    If it exists and is a class
  the component connects to it
  and uses it's functionality.

3. If the local `<script>` tag
class isn't found the __data-connect__
is used as a path to a JavaScript
module. 

4. If the __data-connect__ value
is treated as a path and it ends
with __|SomeName__ it attempts to
load a class named __SomeName__ from
the module (e.g. __export class SomeName {}__)

5. If the __data-connect__ doesn't
have a __|SomeName__ ending then the
module's default class is used 
(i.e. __export default class {}__)

-->

    - document the error message you get if
    you try load a module without 
    a default export class in it. 
</details>

