<h2>Hello, bitty</h2>

[! include "wrapper/do-not-edit-output-reminder.html" !]

<p>bitty is a web component. Wrapping it around elements adds reactivity.
For example, clicking the button below updates the &quot;Waiting&quot; text 
with a timestamp.</p>

<div
  class="make-two-columns warning-border-faded default-radius xxlarge-inline-margin"
>
[!- autoescape false !]
  [@ data.misc_html["hello-text.html"].raw @]
[!- endautoescape !]
</div>

<p>
  bitty uses a signaling approach. Adding
  <code>data-*</code> attributes to elements defines the 
  signals they send and receive.  Here's
  the HTML for the button and text:
</p>

<pre class="code-block large-block-margin"><code>
[!- autoescape false !]
[@- data.misc_html["hello-text.html"].highlighted -@]
[!- endautoescape -!]</code></pre>

<p>Here's the corresponding <code>hello-text.js</code> JavaScript:</p>

<pre class="code-block large-block-margin"><code>
[!- autoescape false !]
[@- data.example_scripts["hello-text.js"].highlighted -@]
[!- endautoescape !]
</code></pre>


<h3>How It Works</h3>

<ul>
  <li>
    The <code>data-bridge</code> attribute on the <code>bitty-js</code> element 
    makes the connection to the JavaScript module responsible for 
    providing functionality. <code>hello-text.js</code> in this case.
  </li>

  <li>
    The <code>data-recieve</code> attribute on the <code>div</code> registers
    it to receive updates when the <code>updateText</code> signal is
    sent. (The element is passed to the <code>updateText</code>
    funciton to receive the updates.)
  </li>

  <li>
    The <code>data-send</code> attribute on the <code>button</code> 
    registers it to send the <code>updateText</code> signal when
    it's clicked. 
  </li>
</ul>

<p>
  That's the core of how bitty works. 
  There are a few other features shown in the examples
  below. Check them out to get an idea
  of what bitty can do.
</p>


