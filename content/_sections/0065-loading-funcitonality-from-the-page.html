<details class="section-details">
  <summary>Loading Functionality from the Page</summary>
[! filter markdown|safe !]
__bitty-js__ can use `<script>` tags on
the page for functinoality. For example,
this `<script>` is in the `<head>` element
of this page:

<pre class="code-block">
[@ highlight["_inline_scripts/main-example-script.html"]|safe @]
</pre>

Using it is done by setting the __data-connection__
attribute of a __bitty-js__ to the name of
the class in the __bittyClasses__ object:

<pre class="code-block">
[@ highlight["_inline_scripts/main-example-html.html"]|safe @]
</pre>

Here's what it looks like:

[! include "_inline_scripts/main-example-html.html" !]



### For Documentation Section

These more technical notes will be moved into
the Documentation section. 

__bitty-js__ components can be powered by either
JavaScript modules or `<script>` tags embedded
directly on the page. The __data-connection__
attribute is used in both cases. 

The order of operations is:

1. Verify there's a __data-connection__
attribute on the component. Stop
processing and throw an error if there
isn't.

2. Use the value from the __data-conneciton__
attribute to see if there's a JavaScript
Map on the window named `BittyClasses`
with a key that mathces the value and contains
a class. For example, 

    `data-connection="InlineExample"` 

    would look for:

    `bittyClasses.InlineExample`

    If it exists and is a class
  the component connects to it
  and uses it's functionality.

3. If the local `<script>` tag
class isn't found the __data-connection__
is used as a path to a JavaScript
module. 

4. If the __data-connection__ value
is treated as a path and it ends
with `|SomeName` it attempts to
load a class named `SomeName` from
the module (e.g. `export class SomeName {}`)

5. If the __data-connection__ doesn't
have a `|SomeName` ending then the
module's default class is used 
(i.e. `export default class {}`)
[! endfilter !]

</details>
