<!DOCTYPE html>
<html lang="en">
  <head>
<style>
:root {
  --load-hider: 0;
}

:root {
  --light--background-color: oklch(0.9634 0.02097 105.642);
  --light--default-color: oklch(0.1951 0.23 105.642);
  --dark--background-color: oklch(0.2124 0.0298 254.092);
  --dark--default-color: oklch(0.8747 0.04454 254.092);
  --hc-light--background-color: oklch(1 0.06752 259.652);
  --hc-light--default-color: oklch(0.0995 0.23 259.652);
  --hc-dark--background-color: oklch(0 0.20706934229967444 142);
  --hc-dark--default-color: oklch(1 0.20411 82);
}

:root {
  --background-color: var(--switch--background-color, var(--light--background-color));
  --default-color: var(--switch--default-color, var(--light--default-color));
}

@media (prefers-color-scheme: dark) {
  :root {
    --background-color: var(--switch--background-color, var(--dark--background-color));
    --default-color: var(--switch--default-color, var(--dark--default-color));
  }
}</style>

<script>
function loadThemeProps() {
  const data = localStorage.getItem("themeProps");
  if (data) {
    data.props.forEach((prop) => {
    });
  }
}
loadThemeProps();</script><style>
html {
  background-color: var(--background-color);
  color: var(--default-color);
}

body {
  background-color: var(--background-color);
  color: var(--default-color);
  opacity: var(--load-hider);
}
</style>
    <link rel="stylesheet" href="/styles/7/0/0//all-colors.css" />
    <script src="/scripts/style-loader.js"></script>
    <script src="https://unpkg.com/@alanwsmith/bitty@7.0.0/bitty-7.0.0.js" type="module"></script>
    <link rel="stylesheet" href="/styles/7/0/0//custom.css" />

<script>
window.BittyUnhide = class {
  bittyReady() {
    this.api.setProp("--load-hider", 1);
  }
}
</script><meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>bitty - dynamic features for your static pages</title>
<meta property="og:title" content="bitty - dynamic features for your static pages" />
<link rel="shortcut icon" href="/favicon.ico" />
<meta name="description" content="bitty is a little web component. It makes it easy to make your static pages interactive." />
<meta property="og:description" content="bitty is a little web component. It makes it easy to make your static pages interactive." />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bitty.alanwsmith.com/" />
<meta property="og:image" content="https:&#x2f;&#x2f;bitty.alanwsmith.com&#x2f;images&#x2f;og-image-6.jpg" />
<meta name="twitter:card" content="summary_large_image" />
<link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/favicon-16x16.png" />
<link rel="manifest" href="/images/favicons/site.webmanifest" />
<link rel="mask-icon" href="/images/favicons/safari-pinned-tab.svg" color="#5bbad5" />  </head>
  <body>
<noscript>
  <p>
    Bitty is a web component that requires JavaScript
    which is not available on this page. You'll need
    to switch to a browser that has it enabled
    to check things out. 
  </p>
  <style>
  :root { --load-hider: 1; }
  </style>
</noscript><bitty-7-0 data-connect="/projects/7/0/0/unhider/script.js Unhider">
<bitty-7-0 data-connect="/projects/7/0/0/code-block-controls/script.js CodeBlockControls">
<bitty-7-0 data-connect="/projects/7/0/0/details-opener/script.js DetailsOpener">


<script>
const t = {
  stars: `<github-stars
  :repo="alanwsmith/bitty"
  :text-color="var(--heading-color)"
  :background-color="var(--faded-match-color)"
></github-stars>`,
};

window.GitHubStars = class {
  bittyInit() {
    if(window.location.hostname !== "localhost") {
      this.api.appendChild(this.api.makeElement(t.stars));
    }
  }
}
</script>

<nav class="default-wrapper">
  <a href="/">bitty</a>

  <a href="/documentation/7/0/0/">documentation</a>

  <a href="/unit-tests/7/0/0/">tests</a>

  <a href="/projects">projects</a>

  <bitty-7-0 data-connect="GitHubStars"></bitty-7-0>
</nav><header class="default-wrapper">
<hgroup>
  <h1>Roadmap</h1>
</hgroup>
</header>
<main class="default-wrapper default-flow">
<h2>Pending</h2>
<p>Items most likely to make it into the next
release.</p>
<ul>
<li>
<p>TODO: Added namespacing capabilities.
Signals can be prefixed with a string
followed by a <code>.</code> where the string
becomes a namespace identifier.</p>
</li>
<li>
<p>TODO: Figure out how to do namespacing
for the methods inside the classes as well
(e.f. <code>data-send=&quot;ns.example&quot;</code> only goes to
this pseudo code style thing:
<code>ns(ev, el) { example(ev, el) {} }</code>.</p>
</li>
<li>
<p>TODO: Do a network test where you have
100 classes in a single file that's used
by multiple elments to see what the
network traffic and caching does.</p>
</li>
<li>
<p>TODO: Do a network test where you have
100 of the same element making the same
data-connect call to a remote file
to see what the network traffic
and caching does.</p>
</li>
<li>
<p>TODO: CONSIDER: <code>.addDataSend(someEl, SIGNALS)</code>
and <code>.addDataReceive(someEl, SIGNALS)</code>
which would let you update an existing elements
<code>data-send</code> and <code>data-recieve</code> with new signals
(creating the attributes if they don't already exist)
Example: <code>this.api.addDataReceive(&quot;signal&quot;, codeBlock);</code></p>
<p>Existing signals would remain on the elements.</p>
</li>
<li>
<p>TODO: CONSIDER: <code>.removeDataSend(someEl, SIGNALS)</code>
and <code>.removeDataReceive(someEl, SIGNALS)</code> which take
signals off the respective <code>data-*</code> attributes.</p>
<p>Multiple signals can be removed.</p>
<p>It's not necessary to add <code>await:</code> on the
removal for a signal. Only the name
is required. If the source signal has
an await it gets removed regardless.</p>
</li>
<li>
<p>TODO: Added <code>this.api.getQuickXXX()</code>
methods that correspond to <code>this.api.getXXX()</code>
methods. The difference is that they
return a payload regardless of if the
fetch fails or not. If the fetch
succeeds, it's returned directly. If
it fails, an alternate error payload
is returned along with an error message
that goes to the console.</p>
</li>
<li>
<p>TODO: Added <code>this.api.getCSS()</code> which is just an
alias to <code>this.api.getTXT()</code> but helps with the
mental model that fits with the other <code>this.api.getXXX()</code>
methods.</p>
</li>
<li>
<p>TODO: Added a feature to the subs for <code>this.api.getXXX</code>
where if the first value is a string it just
alternates the subs without having to do
a nested array.</p>
</li>
<li>
<p>TODO: Added <code>this.api.localForward(EVENT, SIGNAL)</code> which only
forwards inside the current module in the
same way <code>this.api.localTrigger(SIGNAL)</code>
works.</p>
</li>
<li>
<p>TODO: Added <code>el.setProp(KEY, VALUE)</code> which
is shorthand for adding a corresponding
<code>data-KEY</code> attribute to the <code>VALUE</code>
to the element.</p>
</li>
<li>
<p>TODO: CONSIDER: Added <code>ev.setProp(KEY, VALUE)</code> which
is shorthand for adding a corresponding
<code>data-KEY</code> attribute to the <code>VALUE</code>
to the <code>event.target</code>. (This would
keep the APIs consistent, but need
to thing through the implication of
adjusting the <code>.target</code>)</p>
</li>
<li>
<p>TODO: CONSIDER: Added <code>ev.sender.setProp(KEY, VALUE)</code> which
is shorthand for adding a corresponding
<code>data-KEY</code> attribute to the <code>VALUE</code>
to the <code>event.sender</code>. (This would
keep the APIs consistent, but need
to thing through the implication of
adjusting the <code>.sender</code>)</p>
</li>
<li>
<p>TODO: CONFIRM: Documented behavior of <code>el.bittyId</code>
if the element was added outside the
<code>this.api...</code> methods (i.e. that
<code>.bittyId</code> properties are only added when
elements and fragments are created
via <code>this.api...</code> methods. Anything
created with <code>document.createElement()</code>
won't get them automatically)</p>
</li>
</ul>
<h2>Under Consideration</h2>
<ul>
<li>
<p>TODO: Add a <code>this.api.sleep</code> which does
an async sleep for you.</p>
</li>
<li>
<p>TODO: CONFIRM: If <code>el.bittyPreant</code> is
called on a bitty element it searches for
a parent bitty element that it's nested in.
If it finds one, it's return. Otherwise
the result is undefined.</p>
</li>
<li>
<p>TODO: CONFIRM: <code>el.isTarget</code> and <code>el.isSender</code>
work properly with <code>data-use</code> in addition
to <code>data-send</code> and <code>data-receive</code>.</p>
</li>
<li>
<p>TODO: Examine test 1060 to see about the bitty
element picking up event when other bitty element
that are siblings get clicked.</p>
</li>
<li>
<p>TODO: Figure out how to make a better error message if there's
a major problem in a module file that prevents it from loading
all together. For example, an open <code>const problemVar =</code> with
nothing after the <code>=</code> sign. Right now, it just says there's
an error from inside bitty's component with no useful
info about where the error actually occurred.</p>
</li>
<li>
<p>TODO: Added a <code>bittyready</code> signal that fires
at the end of a bitty element's initialization
chain.</p>
</li>
<li>
<p>TODO: CONFIRM UPDATE: Added <code>internal</code> comments
to <code>ev.sendPayload</code> to filter it out of the
<code>jsdoc</code> output for auto generating docs.</p>
</li>
<li>
<p>TODO: Make stress test pages with
nesting, large numbers of elements, updates, etc...</p>
</li>
<li>
<p>TODO: Set up <code>data-init</code> to handle <code>await:SIGNAL</code>
instead of just doing an <code>await</code> if the
function is <code>async</code> (which is what happens
now)</p>
</li>
<li>
<p>Investigate adding all the <code>bittyId</code> and <code>.sender</code> stuff
to empty bitty elements that just make
a connection and populate themselves from
<code>bittyInit</code> or <code>bittyReady</code></p>
</li>
<li>
<p>TODO: Generate sha hashes of files and check them
before deployments to make sure they haven't changed.</p>
</li>
<li>
<p>TODO: Make sure that <code>bittyforward</code>, <code>bittertrigger</code>, etc...
events have <code>.valueXXX</code>, <code>.propXXX</code>, etc.. stuff on them so
they can be used interchangably with other events.</p>
</li>
<li>
<p>TODO: Set up <code>.trigger</code>, <code>.localTrigger</code>, <code>.forward</code>,
and <code>.localForward</code> to be able to pass data like:
<code>this.api.trigger(&quot;SIGNAL_NAME&quot;, { some: &quot;data&quot; })</code></p>
</li>
<li>
<p>TODO: Improve connection error messages</p>
</li>
<li>
<p>TODO: make sure to clean up event listeners
when bitty elements are removed from the page.</p>
</li>
<li>
<p>TODO: consider if <code>data-init</code> should fire
on elements added through <code>this.api</code> .
Current thinking is 'no' because there's
not a good way to know where it's gonna
be on the DOM:</p>
</li>
</ul>
<pre><code>&lt;script&gt;
  window.BittyClass = class {
    example(ev, el) {
      const e = this.api.makeElement('&lt;div data-init=exampleInit&gt;ONE&lt;/div&gt;');
      document.getElementById('test').appendChild(e);
    }

    exampleInit(ev, el) {
      el.innerHTML = 'TWO';
    }
  }
&lt;/script&gt;

&lt;bitty-7-0&gt;
  &lt;button data-send='example' data-receive='example'&gt;Click me&lt;/button&gt;
&lt;/bitty-7-0&gt;

&lt;div id='test'&gt;Waiting&lt;/div&gt;
</code></pre>
<ul>
<li>
<p>TODO: set up async/await so that anything
that happens with .forward, .trigger, or
.localTrigger inside a specific bitty
tag uses await properly? not sure about
this since there's no practical way to
deal with awaiting from other elements.</p>
<p>TODO: Ensure that anything using
<code>async/await</code> directly from <code>data-send</code>
<code>awaits</code> properly.</p>
</li>
<li>
<p>TODO: Examine if there's a way to guarantee
that each import only happens once even if
multiple bitty instances call the same
external module file.</p>
</li>
<li>
<p>TODO: Set up so that <code>data-connect</code> can use
relative file paths (e.g. <code>./here.js</code>)
instead of being limited to <code>http</code> and <code>/</code>
urls.</p>
</li>
<li>
<p>TODO: CONSIDER: Add console log message if a signal
is sent that doesn't have a corresponding function
to handle it. (This probably doesn't make sense
as signals can travel between bitty elements
so the source element might not have a
function that corresponds to a signal it sends).</p>
</li>
<li>
<p>TODO: Add disconnectedCallback() to do cleanup
if a bitty element is removed.</p>
</li>
<li>
<p>TODO: Consider: Adding <code>this.api.makeSVG()</code>
like <code>this.api.getSVG()</code> with all the
replacement stuff.</p>
</li>
<li>
<p>TODO: Consider: adding the state object that
has built-in <code>.isReady()</code> promise check.
(Thinking about this a little more, I'm not
sure it makes sense for direct integration
because loading the data will be so
application specific.)</p>
</li>
<li>
<p>TODO: Investigate: Added a <code>disconnectedCallback()</code>
to clean up anything that can be
removed when a component is removed.</p>
</li>
<li>
<p>TODO: Set up the <code>bitty</code> tag to listen
for signals with <code>data-receive</code> to allow
for things like completely switching out
the contents of the component without
having to rely on a child element calling
<code>.parentNode</code>.</p>
</li>
<li>
<p>TODO: Make sure to cover the removal of
elements and make sure listeners don't
explode.</p>
</li>
<li>
<p>TODO: Consider a list capture method.
e.g. you can grab all the elements
with a given parameter and they
show up in the order
they appear in the DOM.</p>
</li>
</ul>

</main>

</bitty-7-0>
</bitty-7-0>
</bitty-7-0><script>
  setTimeout(() => { 
    document.documentElement.style.setProperty("--load-hider", "1");
  }, 1600);
</script>

<footer class="small-wrapper xsmall-flow xxxlarge-top-margin faded-accent-top-border small-font-size large-bottom-margin large-block-padding">
  <div class="text-align-center">
    bitty's
    <a href="https://github.com/alanwsmith/bitty">source code</a>
<br />
    alan's 
    <a href="https://www.alanwsmith.com/">site</a>, 
    <a href="https://socials.alanwsmith.com/">socials</a>, 
    <a href="https://www.alanwsmith.com/feeds/posts.xml">rss feed</a>, and 
    <a href="https://links.alanwsmith.com/">other projects</a>
  </div>
  <details class="text-align-center"><summary>This work is dedicated to the public domain.</summary>
    <div>By marking the work with a CC0 public domain dedication, the creator is giving up their copyright and allowing reusers to distribute, remix, adapt, and build upon the material in any medium or format, even for commercial purposes.</div>
  </details>
  <div class="text-align-center">
    <a href="https://www.bitty-js.com/">bitty</a> by <a href="https://www.alanwsmith.com/">alan w smith</a> is marked <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0</a>
  </div>
</footer>
    <script src="/components/github-stars-beta-1.js" type="module"></script>


  </body>
</html>
